<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.23">
<meta name="author" content="Andrea Piseri">
<title>APL Problem Solving Competition 2023</title>
<style>
@charset "UTF-8";

@import "https://cdn.jsdelivr.net/gh/bitmaks/cm-web-fonts@latest/fonts.css";

html {
	background: #f7f7f7;
	color: #282828;
	padding: 0;
	margin: 0;
	height: 100%;
}

#header {
	padding-top: 1px;
	margin-top: -1px;
	text-align: center;
	.details {
		display: flex;
		flex-flow: row;
		max-width: fit-content;
		margin-left:auto;
		margin-right:auto;
		br + span::before {
			margin: 1em;
			content: "-";
		}
	}
	width: none;
	background: #eaeaea;
	border-bottom: 1px solid;
}

#toc {
	border-bottom: 1px solid;
	padding-bottom:0.5em;
}

#content {
	width: 80%;
	max-width: 80em;
	margin-left: auto;
	margin-right: auto;
}

#footer {
	bottom:0;
	margin-top: auto;
	border-top: 1px solid;
	max-width: none;
	background: #f0f0f0;
	padding: 1em;
}

body {
	display: flex;
	flex-direction:column;
	padding: 0;
	margin: 0;
	min-height: 100%;
	font-family: Computer Modern Concrete, Georgia, serif;
}

table {
	background: #eaeaea;
	border-collapse: collapse;
	border-radius: 5px;
	border-bottom: 1px solid;
	border-top: 2px solid;
}

th {
	border-bottom: 1px solid;
}

tr {
	padding-left: 20px;
	padding-right: 20px;
}

tbody td {
	padding-left: 10px;
	padding-right: 10px;
}

td p {
	margin: 5px;
	margin: 5px;
}

pre {
	white-space: pre;
	background: #eaeaea !important;
	overflow-x: auto;
	border-radius: 5px;
	padding: 1em;
}

:not(pre) > code {
	background: #eaeaea;
	border-radius: 5px;
}

</style>
<style>
pre.pygments .hll { background-color: #ffffcc }
pre.pygments { background: #f8f8f8; }
pre.pygments .tok-c { color: #3D7B7B; font-style: italic } /* Comment */
pre.pygments .tok-err { border: 1px solid #FF0000 } /* Error */
pre.pygments .tok-k { color: #008000; font-weight: bold } /* Keyword */
pre.pygments .tok-o { color: #666666 } /* Operator */
pre.pygments .tok-ch { color: #3D7B7B; font-style: italic } /* Comment.Hashbang */
pre.pygments .tok-cm { color: #3D7B7B; font-style: italic } /* Comment.Multiline */
pre.pygments .tok-cp { color: #9C6500 } /* Comment.Preproc */
pre.pygments .tok-cpf { color: #3D7B7B; font-style: italic } /* Comment.PreprocFile */
pre.pygments .tok-c1 { color: #3D7B7B; font-style: italic } /* Comment.Single */
pre.pygments .tok-cs { color: #3D7B7B; font-style: italic } /* Comment.Special */
pre.pygments .tok-gd { color: #A00000 } /* Generic.Deleted */
pre.pygments .tok-ge { font-style: italic } /* Generic.Emph */
pre.pygments .tok-ges { font-weight: bold; font-style: italic } /* Generic.EmphStrong */
pre.pygments .tok-gr { color: #E40000 } /* Generic.Error */
pre.pygments .tok-gh { color: #000080; font-weight: bold } /* Generic.Heading */
pre.pygments .tok-gi { color: #008400 } /* Generic.Inserted */
pre.pygments .tok-go { color: #717171 } /* Generic.Output */
pre.pygments .tok-gp { color: #000080; font-weight: bold } /* Generic.Prompt */
pre.pygments .tok-gs { font-weight: bold } /* Generic.Strong */
pre.pygments .tok-gu { color: #800080; font-weight: bold } /* Generic.Subheading */
pre.pygments .tok-gt { color: #0044DD } /* Generic.Traceback */
pre.pygments .tok-kc { color: #008000; font-weight: bold } /* Keyword.Constant */
pre.pygments .tok-kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
pre.pygments .tok-kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
pre.pygments .tok-kp { color: #008000 } /* Keyword.Pseudo */
pre.pygments .tok-kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
pre.pygments .tok-kt { color: #B00040 } /* Keyword.Type */
pre.pygments .tok-m { color: #666666 } /* Literal.Number */
pre.pygments .tok-s { color: #BA2121 } /* Literal.String */
pre.pygments .tok-na { color: #687822 } /* Name.Attribute */
pre.pygments .tok-nb { color: #008000 } /* Name.Builtin */
pre.pygments .tok-nc { color: #0000FF; font-weight: bold } /* Name.Class */
pre.pygments .tok-no { color: #880000 } /* Name.Constant */
pre.pygments .tok-nd { color: #AA22FF } /* Name.Decorator */
pre.pygments .tok-ni { color: #717171; font-weight: bold } /* Name.Entity */
pre.pygments .tok-ne { color: #CB3F38; font-weight: bold } /* Name.Exception */
pre.pygments .tok-nf { color: #0000FF } /* Name.Function */
pre.pygments .tok-nl { color: #767600 } /* Name.Label */
pre.pygments .tok-nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
pre.pygments .tok-nt { color: #008000; font-weight: bold } /* Name.Tag */
pre.pygments .tok-nv { color: #19177C } /* Name.Variable */
pre.pygments .tok-ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
pre.pygments .tok-w { color: #bbbbbb } /* Text.Whitespace */
pre.pygments .tok-mb { color: #666666 } /* Literal.Number.Bin */
pre.pygments .tok-mf { color: #666666 } /* Literal.Number.Float */
pre.pygments .tok-mh { color: #666666 } /* Literal.Number.Hex */
pre.pygments .tok-mi { color: #666666 } /* Literal.Number.Integer */
pre.pygments .tok-mo { color: #666666 } /* Literal.Number.Oct */
pre.pygments .tok-sa { color: #BA2121 } /* Literal.String.Affix */
pre.pygments .tok-sb { color: #BA2121 } /* Literal.String.Backtick */
pre.pygments .tok-sc { color: #BA2121 } /* Literal.String.Char */
pre.pygments .tok-dl { color: #BA2121 } /* Literal.String.Delimiter */
pre.pygments .tok-sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
pre.pygments .tok-s2 { color: #BA2121 } /* Literal.String.Double */
pre.pygments .tok-se { color: #AA5D1F; font-weight: bold } /* Literal.String.Escape */
pre.pygments .tok-sh { color: #BA2121 } /* Literal.String.Heredoc */
pre.pygments .tok-si { color: #A45A77; font-weight: bold } /* Literal.String.Interpol */
pre.pygments .tok-sx { color: #008000 } /* Literal.String.Other */
pre.pygments .tok-sr { color: #A45A77 } /* Literal.String.Regex */
pre.pygments .tok-s1 { color: #BA2121 } /* Literal.String.Single */
pre.pygments .tok-ss { color: #19177C } /* Literal.String.Symbol */
pre.pygments .tok-bp { color: #008000 } /* Name.Builtin.Pseudo */
pre.pygments .tok-fm { color: #0000FF } /* Name.Function.Magic */
pre.pygments .tok-vc { color: #19177C } /* Name.Variable.Class */
pre.pygments .tok-vg { color: #19177C } /* Name.Variable.Global */
pre.pygments .tok-vi { color: #19177C } /* Name.Variable.Instance */
pre.pygments .tok-vm { color: #19177C } /* Name.Variable.Magic */
pre.pygments .tok-il { color: #666666 } /* Literal.Number.Integer.Long */
</style>
</head>
<body class="article">
<div id="header">
<h1>APL Problem Solving Competition 2023</h1>
<div class="details">
<span id="author" class="author">Andrea Piseri</span><br>
<span id="email" class="email"><a href="mailto:andrea.piseri@gmail.com">andrea.piseri@gmail.com</a></span><br>
<span id="revdate">06/08/2023</span>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>This year I participated in the APL Problem Solving Competition organized by Dyalog Ltd, I will document my thoughts about the problems I solved here.</p>
</div>
</div>
<div id="toc" class="toc">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_part_1_bioinformatics">Part 1: Bioinformatics</a>
<ul class="sectlevel2">
<li><a href="#_task_1">Task 1</a></li>
<li><a href="#_task_2">Task 2</a></li>
<li><a href="#_task_3">Task 3</a></li>
<li><a href="#_task_4">Task 4</a></li>
<li><a href="#_task_5">Task 5</a></li>
</ul>
</li>
<li><a href="#_part_2_potpourri">Part 2: Potpourri</a>
<ul class="sectlevel2">
<li><a href="#_task_1_2">Task 1</a></li>
<li><a href="#_task_2_2">Task 2</a></li>
<li><a href="#_task_3_2">Task 3</a></li>
<li><a href="#_task_4_2">Task 4</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div class="sect1">
<h2 id="_part_1_bioinformatics">Part 1: Bioinformatics</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_task_1">Task 1</h3>
<div class="paragraph">
<p>the first problem starts off pretty tame: write a dfn that converts a DNA sequence to RNA, where both input and
outputs are character arrays. The solution doesn’t need much explanation, it’s just replacing the <code>'T'</code>s with <code>'U'</code>s.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="apl"><span></span><span class="tok-nv">rna</span><span class="tok-w">  </span><span class="tok-kd">←</span><span class="tok-w"> </span><span class="tok-kt">{</span><span class="tok-s1">&#39;U&#39;</span><span class="tok-na">@</span><span class="tok-p">(</span><span class="tok-s1">&#39;T&#39;</span><span class="tok-na">∘</span><span class="tok-o">=</span><span class="tok-p">)</span><span class="tok-bp">⍵</span><span class="tok-kt">}</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_task_2">Task 2</h3>
<div class="paragraph">
<p>I had a little more fun with the next one, as I avoided writing down two separate look up tables by arranging my data properly:
the statement calls for a dfn that returns the reverse complement of a DNA sequence.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>First we reverse the sequence: <code>{⌽⍵}</code></p>
</li>
<li>
<p>Then we find look up each element in the string <code>'ACGT'</code>: <code>{'ACGT'⍳⌽⍵}</code></p>
</li>
<li>
<p>The reverse of the same string dictates the replacements: <code>{(⊂'ACGT'⍳⌽⍵)⌷⌽'ACGT'}</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>With a little massaging we end up with the final solution.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="apl"><span></span><span class="tok-nv">revc</span><span class="tok-w"> </span><span class="tok-kd">←</span><span class="tok-w"> </span><span class="tok-kt">{</span><span class="tok-s1">&#39;ACGT&#39;</span><span class="tok-p">(</span><span class="tok-o">⊂</span><span class="tok-na">⍤</span><span class="tok-o">⍳⌷⌽</span><span class="tok-na">⍤</span><span class="tok-o">⊣</span><span class="tok-p">)</span><span class="tok-o">⌽</span><span class="tok-bp">⍵</span><span class="tok-kt">}</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_task_3">Task 3</h3>
<div class="paragraph">
<p>This task calls for a dfn that returns the protein coded by a RNA sequence, terminating at the first stop codon.
Setting up a lookup table is a logical first step:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="apl"><span></span><span class="tok-nv">t</span><span class="tok-w"> </span><span class="tok-kd">←</span><span class="tok-w"> </span><span class="tok-o">↑</span><span class="tok-p">(</span><span class="tok-s1">&#39;UUU&#39;</span><span class="tok-w"> </span><span class="tok-s1">&#39;F&#39;</span><span class="tok-p">)(</span><span class="tok-s1">&#39;CUU&#39;</span><span class="tok-w"> </span><span class="tok-s1">&#39;L&#39;</span><span class="tok-p">)(</span><span class="tok-s1">&#39;AUU&#39;</span><span class="tok-w"> </span><span class="tok-s1">&#39;I&#39;</span><span class="tok-p">)(</span><span class="tok-s1">&#39;GUU&#39;</span><span class="tok-w"> </span><span class="tok-s1">&#39;V&#39;</span><span class="tok-p">)</span>
<span class="tok-nv">t</span><span class="tok-o">⍪</span><span class="tok-kd">←</span><span class="tok-w"> </span><span class="tok-o">↑</span><span class="tok-p">(</span><span class="tok-s1">&#39;UUC&#39;</span><span class="tok-w"> </span><span class="tok-s1">&#39;F&#39;</span><span class="tok-p">)(</span><span class="tok-s1">&#39;CUC&#39;</span><span class="tok-w"> </span><span class="tok-s1">&#39;L&#39;</span><span class="tok-p">)(</span><span class="tok-s1">&#39;AUC&#39;</span><span class="tok-w"> </span><span class="tok-s1">&#39;I&#39;</span><span class="tok-p">)(</span><span class="tok-s1">&#39;GUC&#39;</span><span class="tok-w"> </span><span class="tok-s1">&#39;V&#39;</span><span class="tok-p">)</span>
<span class="tok-w"> </span><span class="tok-na">...</span>
<span class="tok-nv">t</span><span class="tok-o">⍪</span><span class="tok-kd">←</span><span class="tok-w"> </span><span class="tok-o">↑</span><span class="tok-p">(</span><span class="tok-s1">&#39;UGG&#39;</span><span class="tok-w"> </span><span class="tok-s1">&#39;W&#39;</span><span class="tok-p">)(</span><span class="tok-s1">&#39;CGG&#39;</span><span class="tok-w"> </span><span class="tok-s1">&#39;R&#39;</span><span class="tok-p">)(</span><span class="tok-s1">&#39;AGG&#39;</span><span class="tok-w"> </span><span class="tok-s1">&#39;R&#39;</span><span class="tok-p">)(</span><span class="tok-s1">&#39;GGG&#39;</span><span class="tok-w"> </span><span class="tok-s1">&#39;G&#39;</span><span class="tok-p">)</span>
<span class="tok-nv">r_cod</span><span class="tok-w"> </span><span class="tok-nv">amm</span><span class="tok-w"> </span><span class="tok-kd">←</span><span class="tok-w"> </span><span class="tok-o">↓⍉</span><span class="tok-nv">t</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The helper function r_trs does the heavy lifting, splitting the sequence in codons of 3 (<code>x←{↓(⌊3÷⍨≢⍵)3⍴⍵}r</code>),
looking up each one (<code>y←r_cod⍳x</code>) and assinging the corresponding amino-acid (<code>amm⌷⍨∘⊂y</code>).</p>
</div>
<div class="paragraph">
<p>the whole function can be written tacitly, and the final solution just applies it to it’s input and truncates
the result at the first <code>'$'</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="apl"><span></span><span class="tok-nv">r_trs</span><span class="tok-w"> </span><span class="tok-kd">←</span><span class="tok-w"> </span><span class="tok-nv">amm</span><span class="tok-o">⌷</span><span class="tok-na">⍨∘</span><span class="tok-o">⊂</span><span class="tok-nv">r_cod</span><span class="tok-o">⍳</span><span class="tok-kt">{</span><span class="tok-o">↓</span><span class="tok-p">(</span><span class="tok-o">⌊</span><span class="tok-m">3</span><span class="tok-o">÷</span><span class="tok-na">⍨</span><span class="tok-o">≢</span><span class="tok-bp">⍵</span><span class="tok-p">)</span><span class="tok-m">3</span><span class="tok-o">⍴</span><span class="tok-bp">⍵</span><span class="tok-kt">}</span>
<span class="tok-nv">prot</span><span class="tok-w"> </span><span class="tok-kd">←</span><span class="tok-w"> </span><span class="tok-kt">{</span><span class="tok-s1">&#39;$&#39;</span><span class="tok-p">((</span><span class="tok-m">¯1</span><span class="tok-o">+⍳</span><span class="tok-na">⍨</span><span class="tok-p">)</span><span class="tok-o">↑⊢</span><span class="tok-p">)</span><span class="tok-nv">r_trs</span><span class="tok-bp">⍵</span><span class="tok-kt">}</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_task_4">Task 4</h3>
<div class="paragraph">
<p>This was a parsing problem, of which I’ve done entirely too many doing Advent of Code in APL last year:
it all boils down to partitioning and enclosing and partition-enclosing.</p>
</div>
<div class="paragraph">
<p>We need to write a dfn that accepts the path to a fasta file and returns a list of header-sequence pairs
corresponding to the DNA sequences stored in the file.</p>
</div>
<div class="paragraph">
<p>For reference, a fasta file looks something like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code><span></span>&gt;Rosalind_99
AGCCATGTAGCTAACTCAGGTTACATGGGGATGACCCCGCGACTTGGA
TTAGAGTCTCTTTTGGAATAAGCCTGAATGATCCGAGTAGCATCTCAG
&gt;Rosalind_2748
ATCAGGCTACCGTGTTTGCGGACGGGGGCTTAATCTAGCTTCTCATCTCAGCGACGTCTC
CTTGTTGGCACAGCGGTGGCAGGAGGTCCCCGCCGAGGAGCACATCGACCTTTCGGTGTA
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>The lines starting with &gt; are headers, and the following lines contain the DNA sequences.</p>
</div>
<div class="paragraph">
<p>The solution is fairly pedestrian:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Read the file&#8217;s lines with <code>⊃⎕NGET⍵1</code></p>
</li>
<li>
<p>Identify the header lines with (<code>'&gt;'=⊃¨</code>), and use them to partition-enclose the input.</p>
</li>
<li>
<p>For each chunk:</p>
<div class="ulist">
<ul>
<li>
<p><code>,/1↓⍵</code> concatenates all but the header</p>
</li>
<li>
<p><code>⊂' '(1↓(¯1+⍳⍨)↑⊢)⊃⍵</code> gets the header up to the first space character.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="apl"><span></span><span class="tok-nv">readFASTA</span><span class="tok-w"> </span><span class="tok-kd">←</span><span class="tok-w"> </span><span class="tok-kt">{{</span><span class="tok-p">(</span><span class="tok-o">⊂</span><span class="tok-s1">&#39; &#39;</span><span class="tok-p">(</span><span class="tok-m">1</span><span class="tok-o">↓</span><span class="tok-p">(</span><span class="tok-m">¯1</span><span class="tok-o">+⍳</span><span class="tok-na">⍨</span><span class="tok-p">)</span><span class="tok-o">↑⊢</span><span class="tok-p">)</span><span class="tok-o">⊃</span><span class="tok-bp">⍵</span><span class="tok-p">)</span><span class="tok-o">,,</span><span class="tok-na">/</span><span class="tok-m">1</span><span class="tok-o">↓</span><span class="tok-bp">⍵</span><span class="tok-kt">}</span><span class="tok-na">¨</span><span class="tok-p">((</span><span class="tok-s1">&#39;&gt;&#39;</span><span class="tok-o">=⊃</span><span class="tok-na">¨</span><span class="tok-p">)</span><span class="tok-o">⊂⊢</span><span class="tok-p">)</span><span class="tok-o">⊃</span><span class="tok-nf">⎕NGET</span><span class="tok-bp">⍵</span><span class="tok-m">1</span><span class="tok-kt">}</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_task_5">Task 5</h3>
<div class="paragraph">
<p>The task is to write a function that takes a fasta file, extracts the first (only) DNA sequence, and returns
all the proteins coded by it, beginning with a 'M' amino-acid and ending with a stop codon. I approached the
problem by writing a helper function that would turn a sequence of DNA into the amino-acid sequences of its
6 reading frames.</p>
</div>
<div class="paragraph">
<p>Our final solution will look like this (for some definition of <code>crf</code> and <code>aas</code>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="apl"><span></span><span class="tok-nv">orf</span><span class="tok-w"> </span><span class="tok-kd">←</span><span class="tok-w"> </span><span class="tok-kt">{</span><span class="tok-nv">crf</span><span class="tok-na">⍤</span><span class="tok-nv">aas</span><span class="tok-o">⊃⌽⊃</span><span class="tok-nv">readFASTA</span><span class="tok-bp">⍵</span><span class="tok-kt">}</span></code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>We just defined readFASTA, which will give us the sequences.</p>
</li>
<li>
<p><code>⊃⌽⊃</code> takes the last element in the first header-sequence pair.</p>
</li>
<li>
<p><code>aas</code> will be defined later, it outputs the amino-acid sequences for the six reading frames of the DNA sequence.</p>
</li>
<li>
<p><code>crf</code> will be defined later, it accepts a list of amino-acid sequences and outputs their subsequences that begin
with <code>'M'</code> and end right before a <code>'$'</code>.</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_defining_aas">Defining <code>aas</code></h4>
<div class="paragraph">
<p>Here I had the choice between the easy and intuitive solution by composition, or the "smart" solution that probably
has no real benefit in this case.</p>
</div>
<div class="paragraph">
<p>I obviously chose the latter.</p>
</div>
<div class="paragraph">
<p>What I could have done was to extract the reading frames with the help of revc, then convert each DNA sequence into
RNA with <code>rna</code>, finally transcribe into amino-acids with <code>r_trs</code>: It would have looked something like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="apl"><span></span><span class="tok-nv">aas</span><span class="tok-w"> </span><span class="tok-kd">←</span><span class="tok-w"> </span><span class="tok-nv">r_trs</span><span class="tok-na">¨</span><span class="tok-nv">rna</span><span class="tok-na">¨</span><span class="tok-p">(</span><span class="tok-o">,</span><span class="tok-m">0</span><span class="tok-w"> </span><span class="tok-m">1</span><span class="tok-w"> </span><span class="tok-m">2</span><span class="tok-na">∘.</span><span class="tok-o">↓,</span><span class="tok-na">⍥</span><span class="tok-o">⊂</span><span class="tok-na">∘</span><span class="tok-nv">revc</span><span class="tok-na">⍨</span><span class="tok-p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>however, RNA and DNA are dual representations of the same data, so I opted to convert my lookup table into DNA
representation, and write a function to parallel <code>r_trs</code>: this saves us the RNA conversion, and for big inputs it
may perform better (though probably not by a significant amount).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="apl"><span></span><span class="tok-nv">d_cod</span><span class="tok-w"> </span><span class="tok-kd">←</span><span class="tok-w"> </span><span class="tok-s1">&#39;T&#39;</span><span class="tok-na">@</span><span class="tok-p">(</span><span class="tok-s1">&#39;U&#39;</span><span class="tok-na">∘</span><span class="tok-o">=</span><span class="tok-p">)</span><span class="tok-na">¨</span><span class="tok-nv">r_cod</span>
<span class="tok-nv">d_trs</span><span class="tok-w"> </span><span class="tok-kd">←</span><span class="tok-w"> </span><span class="tok-nv">amm</span><span class="tok-o">⌷</span><span class="tok-na">⍨∘</span><span class="tok-o">⊂</span><span class="tok-nv">d_cod</span><span class="tok-o">⍳</span><span class="tok-kt">{</span><span class="tok-o">↓</span><span class="tok-p">(</span><span class="tok-o">⌊</span><span class="tok-m">3</span><span class="tok-o">÷</span><span class="tok-na">⍨</span><span class="tok-o">≢</span><span class="tok-bp">⍵</span><span class="tok-p">)</span><span class="tok-m">3</span><span class="tok-o">⍴</span><span class="tok-bp">⍵</span><span class="tok-kt">}</span>
<span class="tok-nv">aas</span><span class="tok-w">   </span><span class="tok-kd">←</span><span class="tok-w"> </span><span class="tok-nv">d_trs</span><span class="tok-na">¨</span><span class="tok-p">(</span><span class="tok-o">,</span><span class="tok-m">0</span><span class="tok-w"> </span><span class="tok-m">1</span><span class="tok-w"> </span><span class="tok-m">2</span><span class="tok-na">∘.</span><span class="tok-o">↓,</span><span class="tok-na">⍥</span><span class="tok-o">⊂</span><span class="tok-na">∘</span><span class="tok-nv">revc</span><span class="tok-na">⍨</span><span class="tok-p">)</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_retrospective">Retrospective</h4>
<div class="paragraph">
<p>In hindsight, I could have been a little smarter still: observing that the possible codons are just 3-digit numbers
in the base 4 number system with digits <code>'ACGT'</code>, we can leverage the decode primitive.</p>
</div>
<div class="paragraph">
<p><code>{1+4⊥⍉¯1+'ACGT'⍳(⌊3÷⍨≢⍵)3⍴⍵}</code> can substitute the lookup into <code>d_cod</code>, and <code>d_trs</code> can be rewritten as
<code>d_trs ← amm⌷⍨∘⊂{1+4⊥⍉¯1+'ACGT'⍳(⌊3÷⍨≢⍵)3⍴⍵}</code>, provided that amm contains the amino-acid sorted by the
respective codon&#8217;s numeric value.</p>
</div>
<div class="paragraph">
<p>There is no more need for the <code>d_cod</code> or <code>r_cod</code> tables at all! we could even parametrise the solution and
pass either <code>'ACGT'</code> or <code>'ACGU'</code> to get both <code>r_trs</code> and <code>d_trs</code>. The final definition would have looked something like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="apl"><span></span><span class="tok-nv">trs</span><span class="tok-w"> </span><span class="tok-kd">←</span><span class="tok-w"> </span><span class="tok-kt">{</span><span class="tok-nv">amm</span><span class="tok-sr">[</span><span class="tok-m">1</span><span class="tok-o">+</span><span class="tok-m">4</span><span class="tok-o">⊥⍉</span><span class="tok-m">¯1</span><span class="tok-o">+</span><span class="tok-bp">⍺</span><span class="tok-o">⍳</span><span class="tok-p">(</span><span class="tok-o">⌊</span><span class="tok-m">3</span><span class="tok-o">÷</span><span class="tok-na">⍨</span><span class="tok-o">≢</span><span class="tok-bp">⍵</span><span class="tok-p">)</span><span class="tok-m">3</span><span class="tok-o">⍴</span><span class="tok-bp">⍵</span><span class="tok-sr">]</span><span class="tok-kt">}</span>
<span class="tok-nv">aas</span><span class="tok-w"> </span><span class="tok-kd">←</span><span class="tok-w"> </span><span class="tok-s1">&#39;ACGT&#39;</span><span class="tok-na">∘</span><span class="tok-nv">trs</span><span class="tok-na">¨</span><span class="tok-p">(</span><span class="tok-o">,</span><span class="tok-m">0</span><span class="tok-w"> </span><span class="tok-m">1</span><span class="tok-w"> </span><span class="tok-m">2</span><span class="tok-na">∘.</span><span class="tok-o">↓,</span><span class="tok-na">⍥</span><span class="tok-o">⊂</span><span class="tok-na">∘</span><span class="tok-nv">revc</span><span class="tok-na">⍨</span><span class="tok-p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>But we would still be doing duplicate work in the lookups, as well as giving up some opportunities for semplification:
this is what it would look like after addressing those issues.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="apl"><span></span><span class="tok-nv">amm</span><span class="tok-w"> </span><span class="tok-kd">←</span><span class="tok-w"> </span><span class="tok-s1">&#39;KNKNTTTTRSRSIIMIQHQHPPPPRRRRLLLLEDEDAAAAGGGGVVVV$Y$YSSSS$CWCLFLF&#39;</span>
<span class="tok-nv">aas</span><span class="tok-w"> </span><span class="tok-kd">←</span><span class="tok-w"> </span><span class="tok-kt">{{</span><span class="tok-nv">amm</span><span class="tok-sr">[</span><span class="tok-m">1</span><span class="tok-o">+</span><span class="tok-m">4</span><span class="tok-o">⊥⍉</span><span class="tok-p">(</span><span class="tok-o">⌊</span><span class="tok-m">3</span><span class="tok-o">÷</span><span class="tok-na">⍨</span><span class="tok-o">≢</span><span class="tok-bp">⍵</span><span class="tok-p">)</span><span class="tok-m">3</span><span class="tok-o">⍴</span><span class="tok-bp">⍵</span><span class="tok-sr">]</span><span class="tok-kt">}</span><span class="tok-na">¨</span><span class="tok-o">,</span><span class="tok-m">0</span><span class="tok-w"> </span><span class="tok-m">1</span><span class="tok-w"> </span><span class="tok-m">2</span><span class="tok-na">∘.</span><span class="tok-o">↓,</span><span class="tok-na">⍥</span><span class="tok-o">⊂</span><span class="tok-na">∘</span><span class="tok-p">(</span><span class="tok-m">5</span><span class="tok-o">-⌽</span><span class="tok-p">)</span><span class="tok-m">¯1</span><span class="tok-o">+</span><span class="tok-s1">&#39;ACGT&#39;</span><span class="tok-o">⍳</span><span class="tok-bp">⍵</span><span class="tok-kt">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>A nice insight comes from this layout: the last base is ignored in most codons, as can be observed in <code>4 4 4⍴amm</code>
(many rows are constant).</p>
</div>
</div>
<div class="sect3">
<h4 id="_defining_crf">Defining crf</h4>
<div class="paragraph">
<p>Speculation aside, to complete the task we would like - given a list of the amino-acids coded by the reading frames -
to extract any subsequence of one of them, which starts with <code>'M'</code> and ends just before a <code>'$'</code>.</p>
</div>
<div class="paragraph">
<p>Now I find myself in a bit of an embarassing situation: I have two solutions to this task, which diverge at this point.
I definitely submitted the first one, but I am not sure if I ended up overriding my submission with the second solution;
as a result, I am not sure which version ended up being graded. I will just describe them both and worry about it some other time.</p>
</div>
<div class="sect4">
<h5 id="_solution_1">Solution 1</h5>
<div class="paragraph">
<p>We define a 1-modifier <code>_f</code> which takes a monadic function and applies it to each value in <code>⍵</code>, then
(expecting <code>⍺⍺</code> to return a list for each application) concatenates the results together.
This is heavily inspired by rust’s <code>flat_map</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="apl"><span></span><span class="tok-nv">_f</span><span class="tok-w"> </span><span class="tok-kd">←</span><span class="tok-w"> </span><span class="tok-kt">{</span><span class="tok-o">⊃,</span><span class="tok-na">/</span><span class="tok-bp">⍺⍺</span><span class="tok-na">¨</span><span class="tok-bp">⍵</span><span class="tok-kt">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>To construct the solution:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Partition each reading frame by <code>$</code>:</p>
<div class="ulist">
<ul>
<li>
<p><code>'$'∘≠⊆⊢</code> is a tacit function that splits on <code>$</code></p>
</li>
<li>
<p><code>-'$'≠⊢/</code> returns 0 if the sequence ends in <code>$</code>, <code>¯1</code> otherwise. In the latter case,
we need to drop the last chunk from the partitioning.</p>
</li>
<li>
<p><code>(-'$'≠⊢/)↓'$'∘≠⊆⊢</code> puts them together to give the chunks that end just before <code>$</code>.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Given each chunk:</p>
<div class="ulist">
<ul>
<li>
<p><code>'M'∘(=⊂⊢)</code> partition-encloses at the positions of M.</p>
</li>
<li>
<p><code>,⍨\⍤⌽</code> performs a reverse-catenate-scan in reverse (what a mouthful) which yields
the subsequences starting with M and ending at the end of the chunk.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>What’s left is to do some plumbing with <code>_f</code> and make sure the results are unique:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="apl"><span></span><span class="tok-nv">crf</span><span class="tok-w"> </span><span class="tok-kd">←</span><span class="tok-w"> </span><span class="tok-kt">{</span><span class="tok-o">∪</span><span class="tok-s1">&#39;M&#39;</span><span class="tok-na">∘</span><span class="tok-p">(</span><span class="tok-o">,</span><span class="tok-na">⍨\⍤</span><span class="tok-o">⌽</span><span class="tok-p">(</span><span class="tok-o">=⊂⊢</span><span class="tok-p">))</span><span class="tok-nv">_f</span><span class="tok-p">((</span><span class="tok-o">-</span><span class="tok-s1">&#39;$&#39;</span><span class="tok-o">≠⊢</span><span class="tok-na">/</span><span class="tok-p">)</span><span class="tok-o">↓</span><span class="tok-s1">&#39;$&#39;</span><span class="tok-na">∘</span><span class="tok-o">≠⊆⊢</span><span class="tok-p">)</span><span class="tok-nv">_f</span><span class="tok-bp">⍵</span><span class="tok-kt">}</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_solution_2">Solution 2</h5>
<div class="paragraph">
<p>The second solution is arguably a little more interesting, as it doesn’t directly translate from
something you might write in a scalar language.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Concatenate all the reading frames together, separating with <code>'$'</code>:</p>
</li>
<li>
<p><code>s d←(,/,(⊂(+\≢¨))),∘'$'¨⍵</code></p>
<div class="ulist">
<ul>
<li>
<p>to avoid losing information, we also store the positions of the artificially inserted <code>$</code>s,
which are available as the cumulative sum of the lengths.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Find the positions of <code>M</code> and <code>$</code> in the merged input with <code>'M$'(⍸=)¨⊂s</code>.</p>
</li>
<li>
<p>Match each of the Ms to the corresponding <code>$</code>'s position with binary search: <code>i←{↑⍺(⍵[1+⍵⍸⍺])}/ &#8230;&#8203;</code></p>
<div class="ulist">
<ul>
<li>
<p>note that there is always a <code>$</code> at the end of input, so each <code>M</code> finds a corresponding <code>$</code>.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Remove any values where the stop codon was inserted in step 1:
<code>b e←¯1+↓(~i[2;]∊d)/i</code></p>
</li>
<li>
<p>Finally use the indices to select the relevant subsequences: <code>∪b↓¨e↑¨⊂s</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Putting it all together, we get the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="apl"><span></span><span class="tok-nv">crf</span><span class="tok-w"> </span><span class="tok-kd">←</span><span class="tok-w"> </span><span class="tok-kt">{</span>
<span class="tok-w">    </span><span class="tok-nv">s</span><span class="tok-w"> </span><span class="tok-nv">d</span><span class="tok-kd">←</span><span class="tok-p">(</span><span class="tok-o">,</span><span class="tok-na">/</span><span class="tok-o">,</span><span class="tok-p">(</span><span class="tok-o">⊂</span><span class="tok-p">(</span><span class="tok-o">+</span><span class="tok-na">\</span><span class="tok-o">≢</span><span class="tok-na">¨</span><span class="tok-p">)))</span><span class="tok-o">,</span><span class="tok-na">∘</span><span class="tok-s1">&#39;$&#39;</span><span class="tok-na">¨</span><span class="tok-bp">⍵</span>
<span class="tok-w">    </span><span class="tok-nv">b</span><span class="tok-w"> </span><span class="tok-nv">e</span><span class="tok-kd">←</span><span class="tok-m">¯1</span><span class="tok-o">+↓</span><span class="tok-p">(</span><span class="tok-o">~</span><span class="tok-nv">i</span><span class="tok-sr">[</span><span class="tok-m">2</span><span class="tok-sr">;]</span><span class="tok-o">∊</span><span class="tok-nv">d</span><span class="tok-p">)</span><span class="tok-na">/</span><span class="tok-nv">i</span><span class="tok-kd">←</span><span class="tok-o">⊃</span><span class="tok-kt">{</span><span class="tok-o">↑</span><span class="tok-bp">⍺</span><span class="tok-p">(</span><span class="tok-bp">⍵</span><span class="tok-sr">[</span><span class="tok-m">1</span><span class="tok-o">+</span><span class="tok-bp">⍵</span><span class="tok-o">⍸</span><span class="tok-bp">⍺</span><span class="tok-sr">]</span><span class="tok-p">)</span><span class="tok-kt">}</span><span class="tok-na">/</span><span class="tok-s1">&#39;M$&#39;</span><span class="tok-p">(</span><span class="tok-o">⍸=</span><span class="tok-p">)</span><span class="tok-na">¨</span><span class="tok-o">⊂</span><span class="tok-nv">s</span>
<span class="tok-w">    </span><span class="tok-o">∪</span><span class="tok-nv">b</span><span class="tok-o">↓</span><span class="tok-na">¨</span><span class="tok-nv">e</span><span class="tok-o">↑</span><span class="tok-na">¨</span><span class="tok-o">⊂</span><span class="tok-nv">s</span>
<span class="tok-kt">}</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_retrospective_2">Retrospective</h4>
<div class="paragraph">
<p>Looking back on it, the last line might have been better expressed as <code>∪b{s[⍺+⍳⍵-⍺]}¨e</code> to avoid materializing too many
big arrays, but the performance implications of it depend on the implementation.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_part_2_potpourri">Part 2: Potpourri</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_task_1_2">Task 1</h3>
<div class="paragraph">
<p>The task is to write a dfn that computes or validates a vehicle identification number; there are quite a few details involved,
but the long and short of it is that characters in the VIN contribute to a total score according to their value and position,
and the score modulo 11 determines the correct value of the 9th digit.</p>
</div>
<div class="paragraph">
<p>The solution handles a few cases:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>if the VIN contains 16 legal characters, calculate what character can be placed at position 9 to make a valid VIN, and do so.</p>
</li>
<li>
<p>if the VIN contains 17 legal characters, check that the 9th character matches the one that we calculate from the rest of the VIN.</p>
</li>
<li>
<p>otherwise, return <code>¯1</code>.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="apl"><span></span><span class="tok-nv">vinc</span><span class="tok-w"> </span><span class="tok-kd">←</span><span class="tok-w"> </span><span class="tok-nf">⎕D</span><span class="tok-o">,</span><span class="tok-nf">⎕A</span><span class="tok-o">~</span><span class="tok-s1">&#39;IOQ&#39;</span>
<span class="tok-nv">vin</span><span class="tok-w"> </span><span class="tok-kd">←</span><span class="tok-w"> </span><span class="tok-kt">{</span>
<span class="tok-w">    </span><span class="tok-o">~×</span><span class="tok-na">/</span><span class="tok-bp">⍵</span><span class="tok-o">∊</span><span class="tok-nv">vinc</span><span class="tok-bp">:</span><span class="tok-w"> </span><span class="tok-m">¯1</span>
<span class="tok-w">    </span><span class="tok-m">16</span><span class="tok-o">=≢</span><span class="tok-bp">⍵:</span><span class="tok-w"> </span><span class="tok-p">(</span><span class="tok-nv">calc</span><span class="tok-p">(</span><span class="tok-o">⊣</span><span class="tok-na">@</span><span class="tok-m">9</span><span class="tok-p">)</span><span class="tok-o">⊢</span><span class="tok-p">)</span><span class="tok-m">8</span><span class="tok-p">(</span><span class="tok-o">↑,</span><span class="tok-s1">&#39;0&#39;</span><span class="tok-o">,↓</span><span class="tok-p">)</span><span class="tok-bp">⍵</span>
<span class="tok-w">    </span><span class="tok-m">17</span><span class="tok-o">=≢</span><span class="tok-bp">⍵:</span><span class="tok-w"> </span><span class="tok-p">(</span><span class="tok-nv">calc</span><span class="tok-o">=</span><span class="tok-m">9</span><span class="tok-na">∘</span><span class="tok-o">⌷</span><span class="tok-p">)</span><span class="tok-bp">⍵</span>
<span class="tok-w">    </span><span class="tok-m">¯1</span>
<span class="tok-kt">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>We delegate the messy part to the calc helper function, that takes a 17 character vector and returns the character that,
placed at position 9, would make the VIN valid.</p>
</div>
<div class="sect3">
<h4 id="_defining_calc">Defining calc</h4>
<div class="paragraph">
<p>I set up the tables:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>num contains the numeric values to substitute to the characters</p>
</li>
<li>
<p>mul contains the values that digits at each position must be multiplied by.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="apl"><span></span><span class="tok-nv">num</span><span class="tok-w">  </span><span class="tok-kd">←</span><span class="tok-w"> </span><span class="tok-p">((</span><span class="tok-m">65</span><span class="tok-na">∘</span><span class="tok-o">≤×</span><span class="tok-m">1</span><span class="tok-o">+</span><span class="tok-m">9</span><span class="tok-o">|</span><span class="tok-m">83</span><span class="tok-na">∘</span><span class="tok-o">≤+-</span><span class="tok-na">∘</span><span class="tok-m">65</span><span class="tok-p">)</span><span class="tok-o">+</span><span class="tok-p">(</span><span class="tok-m">57</span><span class="tok-na">∘</span><span class="tok-o">≥×-</span><span class="tok-na">∘</span><span class="tok-m">48</span><span class="tok-p">))</span><span class="tok-nf">⎕ucs</span><span class="tok-w"> </span><span class="tok-nv">vinc</span>
<span class="tok-nv">mul</span><span class="tok-w">  </span><span class="tok-kd">←</span><span class="tok-w"> </span><span class="tok-m">10</span><span class="tok-w"> </span><span class="tok-m">0</span><span class="tok-na">@</span><span class="tok-m">8</span><span class="tok-w"> </span><span class="tok-m">9</span><span class="tok-o">⊢</span><span class="tok-m">17</span><span class="tok-o">↑</span><span class="tok-m">2</span><span class="tok-o">↓⌽,</span><span class="tok-na">⍨</span><span class="tok-o">⍳</span><span class="tok-m">10</span>
<span class="tok-nv">calc</span><span class="tok-w"> </span><span class="tok-kd">←</span><span class="tok-w"> </span><span class="tok-kt">{</span><span class="tok-p">(</span><span class="tok-nf">⎕D</span><span class="tok-o">,</span><span class="tok-s1">&#39;X&#39;</span><span class="tok-p">)</span><span class="tok-o">⌷</span><span class="tok-na">⍨</span><span class="tok-m">1</span><span class="tok-o">+</span><span class="tok-m">11</span><span class="tok-o">|</span><span class="tok-nv">mul</span><span class="tok-o">+</span><span class="tok-na">.</span><span class="tok-o">×</span><span class="tok-nv">num</span><span class="tok-o">⌷</span><span class="tok-na">⍨</span><span class="tok-o">⊂</span><span class="tok-nv">vinc</span><span class="tok-o">⍳</span><span class="tok-bp">⍵</span><span class="tok-kt">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The procedure is as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Look up each character’s value with <code>num⌷⍨⊂vinc⍳⍵</code></p>
</li>
<li>
<p>Since the score is calculated via a sum-of-products, the choice falls on inner product: <code>mul +.× &#8230;&#8203;</code></p>
</li>
<li>
<p>take the modulo and pick a digit: <code>(⎕D,'X')⌷⍨1+11| &#8230;&#8203;</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Retrospective</p>
</div>
<div class="paragraph">
<p>the tables defined above look very bad and are not at all insightful, what I should really have written is:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="apl"><span></span><span class="tok-nv">num</span><span class="tok-w">  </span><span class="tok-kd">←</span><span class="tok-w"> </span><span class="tok-p">(</span><span class="tok-o">⍳</span><span class="tok-m">9</span><span class="tok-p">)</span><span class="tok-o">,</span><span class="tok-p">(</span><span class="tok-o">⍳</span><span class="tok-m">8</span><span class="tok-p">)</span><span class="tok-o">,</span><span class="tok-p">((</span><span class="tok-o">⍳</span><span class="tok-m">9</span><span class="tok-p">)</span><span class="tok-o">~</span><span class="tok-m">6</span><span class="tok-w"> </span><span class="tok-m">8</span><span class="tok-p">)</span><span class="tok-o">,</span><span class="tok-m">1</span><span class="tok-o">↓⍳</span><span class="tok-m">9</span>
<span class="tok-nv">mul</span><span class="tok-w">  </span><span class="tok-kd">←</span><span class="tok-w"> </span><span class="tok-p">(</span><span class="tok-o">⊢,</span><span class="tok-m">10</span><span class="tok-w"> </span><span class="tok-m">0</span><span class="tok-w"> </span><span class="tok-m">9</span><span class="tok-o">,⊢</span><span class="tok-p">)</span><span class="tok-o">⌽</span><span class="tok-m">1</span><span class="tok-o">↓⍳</span><span class="tok-m">8</span></code></pre>
</div>
</div>
<div class="olist lowerroman">
<ol class="lowerroman" type="i">
<li>
<p>or even just the raw numbers, it’s not like we’re starved for hard disk space.</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_task_2_2">Task 2</h3>
<div class="paragraph">
<p>This task asked for a function that sorts strings representing software versions according to their release number.
The structure of the input is either:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>a string in the format <code>"<span class="a-zA-Z">-[a-zA-Z]</span>-<span class="0-9">\.[0-9]</span>\.[0-9]+"</code></p>
</li>
<li>
<p>a list of strings in the above format.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The solution leverages total array ordering, and the bulk of the problem just boils down to parsing the numbers in the string.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="apl"><span></span><span class="tok-nv">parts</span><span class="tok-w"> </span><span class="tok-kd">←</span><span class="tok-w"> </span><span class="tok-p">(</span><span class="tok-o">-</span><span class="tok-na">∘</span><span class="tok-o">~</span><span class="tok-na">⍨/</span><span class="tok-s1">&#39;.&#39;</span><span class="tok-nf">⎕vfi</span><span class="tok-o">⊃</span><span class="tok-p">)</span><span class="tok-na">@</span><span class="tok-m">3</span><span class="tok-p">(</span><span class="tok-s1">&#39;-&#39;</span><span class="tok-na">∘</span><span class="tok-o">≠⊆⊢</span><span class="tok-p">)</span>
<span class="tok-nv">sortVersions</span><span class="tok-w"> </span><span class="tok-kd">←</span><span class="tok-w"> </span><span class="tok-kt">{</span><span class="tok-m">1</span><span class="tok-o">=≡</span><span class="tok-bp">⍵:</span><span class="tok-w"> </span><span class="tok-o">,⊂</span><span class="tok-bp">⍵</span><span class="tok-w"> </span><span class="tok-p">⋄</span><span class="tok-w"> </span><span class="tok-p">((</span><span class="tok-o">⊂</span><span class="tok-na">∘</span><span class="tok-o">⍋</span><span class="tok-nv">parts</span><span class="tok-na">¨</span><span class="tok-p">)</span><span class="tok-o">⌷⊢</span><span class="tok-p">)</span><span class="tok-bp">⍵</span><span class="tok-kt">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If the input is a flat character array, then just return it wrapped in a 1-element list.
If it’s a list of strings, split each entry by <code>-</code> into the fields (<code>org</code>, <code>package</code>, <code>version</code>).
Then parse the three numbers in version using <code>⎕vfi</code>: this suggests a nice extension of the problem statement:
if one of the fields in version is not a number, <code>⎕vfi</code> will return a 0 verification bit and a 0 result:
this means that the expression <code>result-~verification</code> returns <code>result</code> if valid, <code>¯1</code> otherwise.</p>
</div>
<div class="paragraph">
<p>This allows us to sort versions like <code>foo-bar-10.x.0</code> in between <code>foo-bar-9.9.9</code> and <code>foo-bar-10.0.0</code>, which is
kind of nice to have.</p>
</div>
<div class="paragraph">
<p>With that out of the way, we have a list of entries in the form:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code><span></span>org package (major minor patch).</code></pre>
</div>
</div>
<div class="paragraph">
<p>Applying <code>⍋</code> gives us a sorting permutation, which by the rules of total array ordering conforms to the problem statement.</p>
</div>
</div>
<div class="sect2">
<h3 id="_task_3_2">Task 3</h3>
<div class="paragraph">
<p>The task is to write a dfn that, given a sorted list of coin denominations (positive integers) as left argument and a
total amount (a positive integer) as right argument, returns a matrix, where each row contains the coefficients of a
linear combination of the elements in the left argument which sums to the right argument. Of course, the matrix should
be exhaustive and not contain any duplicates.</p>
</div>
<div class="paragraph">
<p>Another way to look at this is that it returns the tallest matrix res that satisfies the following constraints:</p>
</div>
<div class="paragraph">
<p><code>⍵∧.=res+.×⍺</code>
<code>res≡∪res</code></p>
</div>
<div class="paragraph">
<p>The solution I submitted is a classic recursive one, with just a little bit of care put into the performance of it:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="apl"><span></span><span class="tok-nv">makeChange</span><span class="tok-w"> </span><span class="tok-kd">←</span><span class="tok-w"> </span><span class="tok-kt">{</span>
<span class="tok-w">    </span><span class="tok-m">0</span><span class="tok-o">≠</span><span class="tok-bp">⍵</span><span class="tok-o">|</span><span class="tok-na">⍨</span><span class="tok-o">∨</span><span class="tok-na">/</span><span class="tok-bp">⍺:</span><span class="tok-w"> </span><span class="tok-p">(</span><span class="tok-m">0</span><span class="tok-o">,≢</span><span class="tok-bp">⍺</span><span class="tok-p">)</span><span class="tok-o">⍴</span><span class="tok-m">0</span>
<span class="tok-w">    </span><span class="tok-m">1</span><span class="tok-o">=≢</span><span class="tok-bp">⍺:</span><span class="tok-w"> </span><span class="tok-o">⍪</span><span class="tok-bp">⍵</span><span class="tok-o">÷⊃</span><span class="tok-bp">⍺</span>
<span class="tok-w">    </span><span class="tok-o">⊃⍪</span><span class="tok-na">/</span><span class="tok-p">(((</span><span class="tok-o">⊂</span><span class="tok-m">¯1</span><span class="tok-o">↓</span><span class="tok-bp">⍺</span><span class="tok-p">)</span><span class="tok-bp">∇</span><span class="tok-na">¨</span><span class="tok-bp">⍵</span><span class="tok-o">-</span><span class="tok-p">(</span><span class="tok-o">⊃⌽</span><span class="tok-bp">⍺</span><span class="tok-p">)</span><span class="tok-o">×⊢</span><span class="tok-p">)</span><span class="tok-o">,</span><span class="tok-na">¨</span><span class="tok-o">⊢</span><span class="tok-p">)</span><span class="tok-m">0</span><span class="tok-o">,⍳⌊</span><span class="tok-bp">⍵</span><span class="tok-o">÷⊃⌽</span><span class="tok-bp">⍺</span>
<span class="tok-kt">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>It is a well known mathematical fact that for a finite set \(A\) of integers, there exists a linear combination in \(A\)
with integer coefficients that sums to \(n\) if and only if \(\text{GCD}(A) | n\)
(where the GCD of a finite set is given by the pairwise GCD reduction of the elements in some arbitrary ordering, and <code>|</code>
is the divisibility symbol). This allows us to immediately return <code>(0,≢⍺)⍴0</code> if <code>⍵</code> is not divisible by <code>∨/⍺</code>,
which prunes some branches.</p>
</div>
<div class="paragraph">
<p>The second line handles the general base case, and it is only reached if there is exactly one trivial solution.
We can avoid checking divisibility because the first line catches the case where <code>0≠⍵|⊃⍺</code>.</p>
</div>
<div class="paragraph">
<p>The third line does all the recursing:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>0,⍳⌊⍵÷⊃⌽⍺</code> determines how many coins of the largest denomination can be taken away from <code>⍵</code>.</p>
</li>
<li>
<p><code>⍵-(⊃⌽⍺)×⊢</code> calculates the amount left over from each operation.</p>
</li>
<li>
<p><code>(⊂¯1↓⍺)∇¨⍵-(⊃⌽⍺)×⊢</code> recurses on each case, removing the largest denomination.</p>
</li>
<li>
<p>a solution of the original problem can be formed by appending \(n\) to a solution of the reduced problem
that takes away \(n\) coins of the largest denomination: therefore</p>
<div class="ulist">
<ul>
<li>
<p><code>(((⊂¯1↓⍺)∇¨⍵-(⊃⌽⍺)×⊢),¨⊢) &#8230;&#8203;</code> gives a list of matrices of the solutions</p>
</li>
<li>
<p><code>⊃⍪/</code> concatenates the solutions together.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>It may look suspicious that we’re not deduplicating the lines, but it can be proven that every solution
gotten this way is already unique:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>the first two cases always return zero or one result, and are trivially unique.</p>
</li>
<li>
<p>by inductive hypothesis, results returned by a recursive call are internally unique.</p>
</li>
<li>
<p>results obtained by two different recursive calls are distinct, since they are joined with distinct values of \(n\).</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_retrospective_3">Retrospective</h4>
<div class="paragraph">
<p>After some thinking, I came up with a more interesting solution for this problem, which I didn’t submit as the
competition had already closed: the idea is to reduce the amount of recursive calls as much as possible,
by allowing the function to take an array right argument and process values of ⍵ in parallel, sharing the recursive
subproblems between them.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="apl"><span></span><span class="tok-nv">makeChange</span><span class="tok-w"> </span><span class="tok-kd">←</span><span class="tok-w"> </span><span class="tok-kt">{</span>
<span class="tok-w">    </span><span class="tok-m">1</span><span class="tok-o">≡≢</span><span class="tok-bp">⍺:</span><span class="tok-w"> </span><span class="tok-p">(</span><span class="tok-m">0</span><span class="tok-o">=</span><span class="tok-bp">⍵</span><span class="tok-o">|</span><span class="tok-na">⍨</span><span class="tok-o">⊃</span><span class="tok-bp">⍺</span><span class="tok-p">)</span><span class="tok-o">↑</span><span class="tok-na">¨</span><span class="tok-o">⍪</span><span class="tok-na">¨</span><span class="tok-bp">⍵</span><span class="tok-o">÷⊃</span><span class="tok-bp">⍺</span>
<span class="tok-w">    </span><span class="tok-nv">d</span><span class="tok-kd">←</span><span class="tok-m">0</span><span class="tok-o">,</span><span class="tok-na">¨</span><span class="tok-o">⍳</span><span class="tok-na">¨</span><span class="tok-o">⌊</span><span class="tok-bp">⍵</span><span class="tok-o">÷</span><span class="tok-nv">i</span><span class="tok-kd">←</span><span class="tok-o">⊢</span><span class="tok-na">/</span><span class="tok-bp">⍺</span>
<span class="tok-w">    </span><span class="tok-nv">u</span><span class="tok-kd">←</span><span class="tok-o">∪∊</span><span class="tok-nv">r</span><span class="tok-kd">←</span><span class="tok-bp">⍵</span><span class="tok-o">-</span><span class="tok-nv">i</span><span class="tok-o">×</span><span class="tok-nv">d</span>
<span class="tok-w">    </span><span class="tok-nv">s</span><span class="tok-kd">←</span><span class="tok-p">(</span><span class="tok-m">¯1</span><span class="tok-o">↓</span><span class="tok-bp">⍺</span><span class="tok-p">)</span><span class="tok-bp">∇</span><span class="tok-nv">u</span>
<span class="tok-w">    </span><span class="tok-o">⊃</span><span class="tok-na">⍣</span><span class="tok-p">(</span><span class="tok-m">0</span><span class="tok-o">≡≢⍴</span><span class="tok-bp">⍵</span><span class="tok-p">)</span><span class="tok-o">⊢</span><span class="tok-nv">r</span><span class="tok-kt">{</span><span class="tok-o">⊃⍪</span><span class="tok-na">/</span><span class="tok-nv">s</span><span class="tok-sr">[</span><span class="tok-nv">u</span><span class="tok-o">⍳</span><span class="tok-bp">⍺</span><span class="tok-sr">]</span><span class="tok-o">,</span><span class="tok-na">¨</span><span class="tok-bp">⍵</span><span class="tok-kt">}</span><span class="tok-na">¨</span><span class="tok-nv">d</span>
<span class="tok-kt">}</span></code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>In the base case, if <code>⍺</code> only has one element, we provide the trivial solution to each element in <code>⍵</code> as a <code>0 1</code> or <code>1 1</code> matrix.</p>
</li>
<li>
<p>otherwise, we generate a list of unique subproblems, recurse, then use them to solve the original problem.</p>
<div class="ulist">
<ul>
<li>
<p><code>d←0,¨⍳¨⌊⍵÷i←⊢/⍺</code> generates a list of lists, each containing the amounts of coins of the biggest denomination that
can be taken from each element of <code>⍵</code>.</p>
</li>
<li>
<p><code>r←⍵-i×d</code> generates the nested list of amounts left over from each operation</p>
</li>
<li>
<p><code>u←∪∊r</code> flattens and deduplicates this list, giving the list of subproblems to recurse on.</p>
</li>
<li>
<p><code>s←(¯1↓⍺)∇u</code> gives the list of solutions to each subproblem</p>
</li>
<li>
<p><code>{⊃⍪/s[u⍳⍺],¨⍵}</code> looks up each element of <code>⍺</code> in the list of subproblems and gives the corresponding solution,
then joins it to <code>⍵</code> and concatenates the results.</p>
</li>
<li>
<p><code>⊃⍣(0≡≢⍴⍵)</code> discloses the result if the right argument was a scalar, so that the result is conformant with the
problem statement.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_task_4_2">Task 4</h3>
<div class="paragraph">
<p>The task is to write a procedure partition that returns sliding windows of the right argument, with the size, strides and
starting position given by the left argument.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="apl"><span></span><span class="tok-nv">partition</span><span class="tok-w"> </span><span class="tok-kd">←</span><span class="tok-w"> </span><span class="tok-kt">{</span>
<span class="tok-w">    </span><span class="tok-m">1</span><span class="tok-w"> </span><span class="tok-m">0</span><span class="tok-o">∊</span><span class="tok-na">⍨</span><span class="tok-o">≡</span><span class="tok-bp">⍺:</span><span class="tok-w"> </span><span class="tok-p">(</span><span class="tok-o">⊂,</span><span class="tok-bp">⍺</span><span class="tok-p">)</span><span class="tok-bp">∇⍵</span>
<span class="tok-w">    </span><span class="tok-p">(</span><span class="tok-o">≢⍴</span><span class="tok-bp">⍵</span><span class="tok-p">)</span><span class="tok-o">&lt;≢⊃</span><span class="tok-bp">⍺:</span><span class="tok-w"> </span><span class="tok-m">0</span><span class="tok-o">↑⊂</span><span class="tok-p">(</span><span class="tok-o">⊃</span><span class="tok-bp">⍺</span><span class="tok-p">)</span><span class="tok-o">⍴</span><span class="tok-no">⍬</span>
<span class="tok-w">    </span><span class="tok-nv">s</span><span class="tok-w"> </span><span class="tok-nv">m</span><span class="tok-w"> </span><span class="tok-nv">o</span><span class="tok-kd">←</span><span class="tok-p">(</span><span class="tok-o">≢⍴</span><span class="tok-bp">⍵</span><span class="tok-p">)(</span><span class="tok-o">⊢,</span><span class="tok-na">⍨</span><span class="tok-m">1</span><span class="tok-o">⍴</span><span class="tok-na">⍨</span><span class="tok-o">-</span><span class="tok-na">∘</span><span class="tok-o">≢</span><span class="tok-p">)</span><span class="tok-na">¨</span><span class="tok-m">3</span><span class="tok-o">↑</span><span class="tok-bp">⍺</span><span class="tok-o">,</span><span class="tok-no">⍬⍬</span>
<span class="tok-w">    </span><span class="tok-o">,⊂</span><span class="tok-na">⍤</span><span class="tok-p">((</span><span class="tok-o">⊃</span><span class="tok-bp">⍺</span><span class="tok-p">)</span><span class="tok-na">∘</span><span class="tok-o">⍴</span><span class="tok-p">)</span><span class="tok-na">⍤</span><span class="tok-p">(</span><span class="tok-o">≢</span><span class="tok-nv">s</span><span class="tok-p">)</span><span class="tok-o">⊢</span><span class="tok-bp">⍵</span><span class="tok-sr">[</span><span class="tok-p">(</span><span class="tok-m">¯1</span><span class="tok-o">+⍳</span><span class="tok-nv">s</span><span class="tok-p">)</span><span class="tok-na">∘.</span><span class="tok-o">+</span><span class="tok-na">⍨</span><span class="tok-p">(</span><span class="tok-o">⊂</span><span class="tok-nv">o</span><span class="tok-p">)</span><span class="tok-o">+</span><span class="tok-p">(</span><span class="tok-o">⊂</span><span class="tok-nv">m</span><span class="tok-p">)</span><span class="tok-o">×</span><span class="tok-m">¯1</span><span class="tok-o">+⍳</span><span class="tok-m">0</span><span class="tok-o">⌈</span><span class="tok-m">1</span><span class="tok-o">+⌊</span><span class="tok-nv">m</span><span class="tok-o">÷</span><span class="tok-na">⍨</span><span class="tok-p">(</span><span class="tok-o">⍴</span><span class="tok-bp">⍵</span><span class="tok-p">)</span><span class="tok-o">-</span><span class="tok-nv">o</span><span class="tok-o">+</span><span class="tok-nv">s</span><span class="tok-o">-</span><span class="tok-m">1</span><span class="tok-sr">]</span>
<span class="tok-kt">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>We start by parsing the left argument, case by case.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If <code>⍺</code> is simple, we enclose it (it will be used to construct <code>s</code> later): <code>(⊂,⍺)∇⍵</code></p>
</li>
<li>
<p>If <code>⍺</code> is nested:</p>
<div class="ulist">
<ul>
<li>
<p>If <code>≢⊃⍺</code> is greater than the rank of <code>⍵</code>, we are being asked for a window that can’t be found in the array,
and we return the empty list, however we also set the fill element to be the desired shape,
to maintain the invariant <code>(⊃⍺)≡⍴⊃⍺partition⍵</code>.</p>
</li>
<li>
<p>The rest of our code assumes input in the format <code>s m o</code> where:</p>
<div class="ulist">
<ul>
<li>
<p><code>s</code> designates the shape of the windows.</p>
</li>
<li>
<p><code>m</code> designates the strides of the windows along each dimension.</p>
</li>
<li>
<p><code>o</code> designates the origin of the first window.
      	Each of these may be underspecified (that is, given as a list that is shorter than the rank of <code>⍵</code>,
or omitted completely. in this case, the implied value for the omitted leading dimensions is 1.
To make sure our arrays are in this format:</p>
<div class="ulist">
<ul>
<li>
<p><code>3↑⍺,⍬⍬</code>: Pad <code>⍺</code> with instances of <code>⍬</code> up to 3 elements:</p>
</li>
<li>
<p><code>(≢⍴⍵)(⊢,⍨1⍴⍨-∘≢)¨ &#8230;&#8203;</code>: Prepend 1s to each element, up to <code>≢⍴⍵</code>.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>Then, our strategy is to generate indices into ⍵ to build up the resulting windows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>(⍴⍵)-o+s-1</code>: The counts of the distinct (non-trivial) origins for a window of shape <code>s</code> along each axis:
each window has to start at a position <code>pos</code> such that: <code>∧/ (o ≤ pos) , pos ≤ (⍴⍵)-s</code>.
If no windows fit along an axis, the corresponding component is negative.</p>
</li>
<li>
<p><code>0⌈1+⌊m÷⍨ &#8230;&#8203;</code>: Divide by the strides to get the counts of windows actually in the result; clamp negative components up to 0.</p>
</li>
<li>
<p><code>(⊂o)(⊂m)×¯1⍳ &#8230;&#8203;</code>: Generate the origin of each window as the sum of the base position <code>o</code> and an offset.</p>
</li>
<li>
<p><code>(¯1+⍳s)∘.+⍨ &#8230;&#8203;</code>: Sum each window’s origin with each offset in the shape of the window with outer product.
the commute is used to make sure the rank <code>≢s</code> cells of the result correspond to windows.</p>
</li>
<li>
<p><code>⍵[ &#8230;&#8203; ]</code>: Index into <code>⍵</code> with the generated indices.</p>
</li>
<li>
<p><code>⊂⍤((⊃⍺)∘⍴)⍤(≢s) &#8230;&#8203;</code>: Pick the cells of rank <code>≢s</code> (each corresponding to a window) and enclose them after giving
them the requested shape, finally unravel the result.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Retrospective:</p>
</div>
<div class="paragraph">
<p>I didn’t feel satisfied with this solution, mainly because it uses way too many enclosed arrays as indices.
Here it is, rewritten to convert to scalar indices in ravel order. I took the opportunity to modify a couple
other things I wasn’t happy with:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Take <code>⎕IO</code> into account instead of assuming <code>⎕IO←1</code>.</p>
</li>
<li>
<p>Use <code>⊆</code> to conditionally enclose <code>⍺</code> instead of using recursion.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="apl"><span></span><span class="tok-nv">I</span><span class="tok-w"> </span><span class="tok-kd">←</span><span class="tok-w"> </span><span class="tok-kt">{</span><span class="tok-bp">⍵</span><span class="tok-o">⊤</span><span class="tok-nf">⎕IO</span><span class="tok-o">-</span><span class="tok-na">⍨</span><span class="tok-o">⍳×</span><span class="tok-na">/</span><span class="tok-bp">⍵</span><span class="tok-kt">}</span>
<span class="tok-nv">partition</span><span class="tok-w"> </span><span class="tok-kd">←</span><span class="tok-w"> </span><span class="tok-kt">{</span>
<span class="tok-w">    </span><span class="tok-p">(</span><span class="tok-o">≢⍴</span><span class="tok-bp">⍵</span><span class="tok-p">)</span><span class="tok-o">&lt;≢⊃</span><span class="tok-nv">a</span><span class="tok-kd">←</span><span class="tok-o">⊆</span><span class="tok-bp">⍺:</span><span class="tok-w"> </span><span class="tok-m">0</span><span class="tok-o">↑⊂</span><span class="tok-p">(</span><span class="tok-o">⊃</span><span class="tok-nv">a</span><span class="tok-p">)</span><span class="tok-o">⍴</span><span class="tok-no">⍬</span>
<span class="tok-w">    </span><span class="tok-nv">s</span><span class="tok-w"> </span><span class="tok-nv">m</span><span class="tok-w"> </span><span class="tok-nv">o</span><span class="tok-kd">←</span><span class="tok-p">(</span><span class="tok-o">-</span><span class="tok-nv">r</span><span class="tok-p">)</span><span class="tok-o">↑</span><span class="tok-na">¨</span><span class="tok-p">(</span><span class="tok-o">⊂</span><span class="tok-p">(</span><span class="tok-nv">r</span><span class="tok-kd">←</span><span class="tok-o">≢</span><span class="tok-nv">sw</span><span class="tok-kd">←</span><span class="tok-o">⍴</span><span class="tok-bp">⍵</span><span class="tok-p">)</span><span class="tok-o">⍴</span><span class="tok-m">1</span><span class="tok-p">)</span><span class="tok-o">,</span><span class="tok-na">¨</span><span class="tok-m">3</span><span class="tok-o">↑</span><span class="tok-nv">a</span><span class="tok-o">,</span><span class="tok-no">⍬⍬</span>
<span class="tok-w">    </span><span class="tok-nv">or</span><span class="tok-kd">←</span><span class="tok-nv">sw</span><span class="tok-o">⊥</span><span class="tok-nv">m</span><span class="tok-o">×</span><span class="tok-na">⍤</span><span class="tok-m">0</span><span class="tok-w"> </span><span class="tok-m">1</span><span class="tok-nv">I</span><span class="tok-w"> </span><span class="tok-m">0</span><span class="tok-o">⌈</span><span class="tok-m">1</span><span class="tok-o">+⌊</span><span class="tok-nv">m</span><span class="tok-o">÷</span><span class="tok-na">⍨</span><span class="tok-nv">sw</span><span class="tok-o">-</span><span class="tok-nv">s</span><span class="tok-o">+</span><span class="tok-nv">o</span><span class="tok-o">-</span><span class="tok-nf">⎕IO</span>
<span class="tok-w">    </span><span class="tok-o">⊂</span><span class="tok-na">⍤</span><span class="tok-m">¯1</span><span class="tok-o">⊢</span><span class="tok-p">((</span><span class="tok-o">≢</span><span class="tok-nv">or</span><span class="tok-p">)</span><span class="tok-o">,⊃</span><span class="tok-nv">a</span><span class="tok-p">)</span><span class="tok-o">⍴</span><span class="tok-p">(</span><span class="tok-o">⊂</span><span class="tok-nf">⎕IO</span><span class="tok-o">+</span><span class="tok-p">(</span><span class="tok-nv">or</span><span class="tok-o">+</span><span class="tok-nv">sw</span><span class="tok-o">⊥</span><span class="tok-nv">o</span><span class="tok-o">-</span><span class="tok-nf">⎕IO</span><span class="tok-p">)</span><span class="tok-na">∘.</span><span class="tok-o">+</span><span class="tok-nv">sw</span><span class="tok-o">⊥</span><span class="tok-nv">I</span><span class="tok-w"> </span><span class="tok-nv">s</span><span class="tok-p">)</span><span class="tok-o">⌷,</span><span class="tok-bp">⍵</span>
<span class="tok-kt">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The result is a little longer, but arguably simpler:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>0⌈1+⌊m÷⍨sw-s+o-⎕IO</code> is exactly as before, but accounts for <code>⎕IO</code>.</p>
</li>
<li>
<p><code>I ← {⍵⊤⎕IO-⍨⍳×/⍵}</code> defines a function equivalent to <code>{⍉⎕IO-⍨↑,⍳⍵}</code> but doesn’t use nested arrays.
That is, it generates a matrix whose columns are the 0-based indices into an array of shape <code>⍵</code>, given in ravel order.</p>
</li>
<li>
<p><code>or←sw⊥m×⍤0 1I &#8230;&#8203;</code> generates the 0-based indices into <code>,⍵</code> of the origins of the windows.
(the pattern <code>sw⊥ &#8230;&#8203;</code> is used to convert a matrix whose columns are 0-based indices (or offsets) into <code>⍵</code> to a list
of corresponding indices (or offsets) into <code>,⍵</code>)</p>
</li>
<li>
<p><code>sw⊥I s</code> gives the offset in <code>,⍵</code> of each element in a window from the origin of the same window.</p>
</li>
<li>
<p><code>(⊂⎕IO+(or+sw⊥o-⎕IO)∘.+sw⊥I s)⌷,⍵</code> builds up windows of indices and uses them to pick from <code>,⍵</code></p>
</li>
<li>
<p><code>⊂⍤¯1⊢((≢or),⊃a)⍴ &#8230;&#8203;</code> adjusts the shape of the windows and encloses the results.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If nothing else, this shows my issue with <code>⎕IO</code>: as soon as you start doing arithmetic on indices it gets in the way.
If <code>⎕IO</code> was always 0, the solution could be simplified to:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="apl"><span></span><span class="tok-nv">I</span><span class="tok-w"> </span><span class="tok-kd">←</span><span class="tok-w"> </span><span class="tok-kt">{</span><span class="tok-bp">⍵</span><span class="tok-o">⊤⍳×</span><span class="tok-na">/</span><span class="tok-bp">⍵</span><span class="tok-kt">}</span>
<span class="tok-nv">partition</span><span class="tok-w"> </span><span class="tok-kd">←</span><span class="tok-w"> </span><span class="tok-kt">{</span>
<span class="tok-w">    </span><span class="tok-p">(</span><span class="tok-o">≢⍴</span><span class="tok-bp">⍵</span><span class="tok-p">)</span><span class="tok-o">&lt;≢⊃</span><span class="tok-nv">a</span><span class="tok-kd">←</span><span class="tok-o">⊆</span><span class="tok-bp">⍺:</span><span class="tok-w"> </span><span class="tok-m">0</span><span class="tok-o">↑⊂</span><span class="tok-p">(</span><span class="tok-o">⊃</span><span class="tok-nv">a</span><span class="tok-p">)</span><span class="tok-o">⍴</span><span class="tok-no">⍬</span>
<span class="tok-w">    </span><span class="tok-nv">s</span><span class="tok-w"> </span><span class="tok-nv">m</span><span class="tok-w"> </span><span class="tok-nv">o</span><span class="tok-kd">←</span><span class="tok-p">(</span><span class="tok-o">-</span><span class="tok-nv">r</span><span class="tok-p">)</span><span class="tok-o">↑</span><span class="tok-na">¨</span><span class="tok-p">(</span><span class="tok-o">⊂</span><span class="tok-p">(</span><span class="tok-nv">r</span><span class="tok-kd">←</span><span class="tok-o">≢</span><span class="tok-nv">sw</span><span class="tok-kd">←</span><span class="tok-o">⍴</span><span class="tok-bp">⍵</span><span class="tok-p">)</span><span class="tok-o">⍴</span><span class="tok-m">1</span><span class="tok-p">)</span><span class="tok-o">,</span><span class="tok-na">¨</span><span class="tok-m">3</span><span class="tok-o">↑</span><span class="tok-nv">a</span><span class="tok-o">,</span><span class="tok-no">⍬⍬</span>
<span class="tok-w">    </span><span class="tok-nv">or</span><span class="tok-kd">←</span><span class="tok-nv">sw</span><span class="tok-o">⊥</span><span class="tok-nv">m</span><span class="tok-o">×</span><span class="tok-na">⍤</span><span class="tok-m">0</span><span class="tok-w"> </span><span class="tok-m">1</span><span class="tok-nv">I</span><span class="tok-w"> </span><span class="tok-m">0</span><span class="tok-o">⌈</span><span class="tok-m">1</span><span class="tok-o">+⌊</span><span class="tok-nv">m</span><span class="tok-o">÷</span><span class="tok-na">⍨</span><span class="tok-nv">sw</span><span class="tok-o">-</span><span class="tok-nv">s</span><span class="tok-o">+</span><span class="tok-nv">o</span>
<span class="tok-w">    </span><span class="tok-o">⊂</span><span class="tok-na">⍤</span><span class="tok-m">¯1</span><span class="tok-o">⊢</span><span class="tok-p">((</span><span class="tok-o">≢</span><span class="tok-nv">or</span><span class="tok-p">)</span><span class="tok-o">,⊃</span><span class="tok-nv">a</span><span class="tok-p">)</span><span class="tok-o">⍴</span><span class="tok-p">(</span><span class="tok-o">⊂</span><span class="tok-p">(</span><span class="tok-nv">or</span><span class="tok-o">+</span><span class="tok-nv">sw</span><span class="tok-o">⊥</span><span class="tok-nv">o</span><span class="tok-p">)</span><span class="tok-na">∘.</span><span class="tok-o">+</span><span class="tok-nv">sw</span><span class="tok-o">⊥</span><span class="tok-nv">I</span><span class="tok-w"> </span><span class="tok-nv">s</span><span class="tok-p">)</span><span class="tok-o">⌷,</span><span class="tok-bp">⍵</span>
<span class="tok-kt">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>It also exemplifies how keeping the data representation flat can simplify the reasoning, as well as improving the performance:
the new version is about 28x faster than the old one on <code>3 3 3 partition 25 25 25⍴⎕A</code>.</p>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2024-09-02 18:43:17 +0200
</div>
</div>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  messageStyle: "none",
  tex2jax: {
    inlineMath: [["\\(", "\\)"]],
    displayMath: [["\\[", "\\]"]],
    ignoreClass: "nostem|nolatexmath"
  },
  asciimath2jax: {
    delimiters: [["\\$", "\\$"]],
    ignoreClass: "nostem|noasciimath"
  },
  TeX: { equationNumbers: { autoNumber: "none" } }
})
MathJax.Hub.Register.StartupHook("AsciiMath Jax Ready", function () {
  MathJax.InputJax.AsciiMath.postfilterHooks.Add(function (data, node) {
    if ((node = data.script.parentNode) && (node = node.parentNode) && node.classList.contains("stemblock")) {
      data.math.root.display = "block"
    }
    return data
  })
})
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/MathJax.js?config=TeX-MML-AM_HTMLorMML"></script>
</body>
</html>